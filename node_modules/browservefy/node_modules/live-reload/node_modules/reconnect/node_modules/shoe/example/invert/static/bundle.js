(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"browser.js\"}\n//@ sourceURL=/package.json"
));

require.define("/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar sockjs = require('sockjs-client');\n\nmodule.exports = function (uri, cb) {\n    if (/^\\/\\/[^\\/]+\\//.test(uri)) {\n        uri = window.location.protocol + uri;\n    }\n    else if (!/^https?:\\/\\//.test(uri)) {\n        uri = window.location.protocol + '//'\n            + window.location.host\n            + (/^\\//.test(uri) ? uri : '/' + uri)\n        ;\n    }\n    \n    var stream = new Stream;\n    stream.readable = true;\n    stream.writable = true;\n    \n    var ready = false;\n    var buffer = [];\n    \n    var sock = sockjs.create(uri);\n    stream.sock = sock;\n    \n    stream.write = function (msg) {\n        if (!ready || buffer.length) buffer.push(msg)\n        else sock.send(msg)\n    };\n    \n    stream.end = function (msg) {\n        if (msg !== undefined) stream.write(msg);\n        if (!ready) {\n            stream._ended = true;\n            return;\n        }\n        stream.writable = false;\n        sock.close();\n    };\n    \n    stream.destroy = function () {\n        stream._ended = true;\n        stream.writable = stream.readable = false;\n        buffer.length = 0\n        sock.close();\n    };\n    \n    sock.onopen = function () {\n        if (typeof cb === 'function') cb();\n        ready = true;\n        buffer.forEach(function (msg) {\n            sock.send(msg);\n        });\n        buffer = [];\n        stream.emit('connect')\n        if (stream._ended) stream.end();\n    };\n    \n    sock.onmessage = function (e) {\n        stream.emit('data', e.data);\n    };\n    \n    sock.onclose = function () {\n        stream.emit('end');\n        stream.writable = false;\n        stream.readable = false;\n    };\n    \n    return stream;\n};\n\n//@ sourceURL=/browser.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/sockjs-client/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/sockjs-client/package.json"
));

require.define("/node_modules/sockjs-client/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require('./lib/sockjs-client');\n\n//@ sourceURL=/node_modules/sockjs-client/index.js"
));

require.define("/node_modules/sockjs-client/lib/sockjs-client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"(function (parent) {\n    'use strict';\n\n    var url    = require('url'),\n        http   = require('http'),\n        https  = require('https'),\n        uuid   = require('node-uuid'),\n        events = require('events'),\n        util;\n\n    function InvalidURL (parsedURL) {\n        this.parsedURL = parsedURL;\n    }\n    InvalidURL.prototype = {\n        prototype: Error.prototype,\n        toString: function () { return \"Invalid URL: \" + this.parsedURL.href; }\n    };\n\n    function InvalidState (extra) {\n        this.extra = extra;\n    }\n    InvalidState.prototype = {\n        prototype: Error.prototype,\n        toString: function () { return \"Invalid State \" + this.extra; }\n    };\n\n    util = (function () {\n        var empty = {};\n        return {\n            hasOwnProperty: function (obj, field) {\n                return empty.hasOwnProperty.call(obj, field);\n            },\n\n            shallowCopy: function (src, dest) {\n                var keys = Object.keys(src),\n                    i;\n                for (i = 0; i < keys.length; i += 1) {\n                    dest[keys[i]] = src[keys[i]];\n                }\n            },\n\n            liftFunctions: function (src, dest, fields) {\n                var i, field;\n                for (i = 0; i < fields.length; i += 1) {\n                    field = fields[i];\n                    if (undefined !== src[field] &&\n                        undefined !== src[field].call) {\n                        dest[field] = src[field].bind(src);\n                    }\n                }\n            }\n        };\n    }());\n\n    function SockJSClient (server) {\n        var parsed, serverId, sessionId;\n\n        parsed = url.parse(server);\n\n        if ('http:' === parsed.protocol) {\n            this.client = http;\n        } else if ('https:' === parsed.protocol) {\n            this.client = https;\n        } else {\n            throw new InvalidURL(parsed);\n        }\n\n        if (parsed.pathname === '/') {\n            parsed.pathname = '';\n        }\n\n        serverId = Math.round(Math.random() * 999);\n        sessionId = uuid();\n\n        this.server = url.parse(\n            parsed.protocol + \"//\" + parsed.host + parsed.pathname +\n                \"/\" + serverId + \"/\" + sessionId);\n\n        this.error = Object.getPrototypeOf(this).error.bind(this);\n        this.connection = Object.getPrototypeOf(this).connection.bind(this);\n        this.closed = Object.getPrototypeOf(this).closed.bind(this);\n\n        this.emitter = new events.EventEmitter();\n        util.liftFunctions(\n            this.emitter, this,\n            ['on', 'once', 'removeListener', 'removeAllListeners', 'emit']);\n\n        this.writeBuffer = [];\n    }\n\n    SockJSClient.prototype = {\n        isReady:   false,\n        isClosing: false,\n        isClosed:  false,\n\n        connect: function () {\n            if (this.isReady || this.isClosing || this.isClosed) {\n                return;\n            }\n            var transport = new XHRStreaming(this);\n            transport.on('error', this.error);\n            transport.on('connection', this.connection);\n            transport.on('close', this.closed);\n            (new StateMachine(transport)).invoke();\n        },\n\n        connection: function (transport) {\n            if (this.isClosing) {\n                transport.close();\n            } else if (! (this.isReady || this.isClosed)) {\n                this.isReady = true;\n                this.transport = transport;\n                this.emit('connection');\n                if (0 !== this.writeBuffer.length) {\n                    transport.write(this.writeBuffer);\n                    this.writeBuffer = [];\n                }\n            }\n        },\n\n        error: function () {\n            this.isReady = false;\n            var args = Array.prototype.slice.call(arguments, 0);\n            args.unshift('error');\n            this.emit.apply(this, args);\n            if (this.isClosing) {\n                this.closed();\n            }\n        },\n\n        write: function (message) {\n            if (this.isClosed || this.isClosing) {\n                return;\n            } else if (this.isReady) {\n                return this.transport.write([message]);\n            } else {\n                this.writeBuffer.push(message);\n            }\n        },\n\n        close: function () {\n            if (! (this.isClosing || this.isClosed)) {\n                this.isClosing = true;\n                if (this.isReady) {\n                    this.isReady = false;\n                    this.transport.close();\n                }\n            }\n        },\n\n        closed: function () {\n            if (! this.isClosed) {\n                var args = Array.prototype.slice.call(arguments, 0);\n                args.unshift('close');\n                this.emit.apply(this, args);\n            }\n            this.isClosed  = true;\n            this.isClosing = false;\n            this.isReady   = false;\n        }\n    };\n\n    function XHRStreaming (sjs) {\n        this.sjs = sjs;\n        this.emitter = new events.EventEmitter();\n        util.liftFunctions(\n            this.emitter, this,\n            ['on', 'once', 'removeListener', 'removeAllListeners', 'emit']);\n        this.error = Object.getPrototypeOf(this).error.bind(this);\n        this.initialPayloadRemaining = this.initialPayloadLength;\n        this.partialChunk = \"\";\n    }\n    XHRStreaming.prototype = {\n        fsm: {'start':          'connected',\n              'connected':      'dataInitial',\n              'dataInitial':    'dataOpen',\n              'dataOpen':       'running',\n              'running':        'running',\n              'errored':        'errored'\n             },\n\n        initialPayloadLength: 2049,\n\n        start: function (sm) {\n            var request = {method: 'POST',\n                           headers: {'Content-Length': 0}},\n                clientRequest;\n            util.shallowCopy(this.sjs.server, request);\n            request.path += '/xhr_streaming';\n            clientRequest = this.sjs.client.request(request, sm.stepper());\n            clientRequest.on('error', this.error.bind(this, sm));\n            clientRequest.end();\n        },\n\n        write: function (message) {\n            var data = JSON.stringify(message),\n                request = {method: 'POST',\n                           headers: {\n                               'Content-Type': 'application/json',\n                               'Content-Length': Buffer.byteLength(data,'utf8')}},\n                clientRequest;\n            util.shallowCopy(this.sjs.server, request);\n            request.path += '/xhr_send';\n            clientRequest = this.sjs.client.request(request);\n            clientRequest.write(data);\n            clientRequest.end();\n        },\n\n        close: function () {\n            if (undefined !== this.response) {\n                this.response.removeAllListeners();\n                this.response.destroy();\n            }\n            this.emit('close');\n        },\n\n        connected: function (sm, result) {\n            this.response = result;\n            if (200 !== result.statusCode) {\n                this.error(sm, result.statusCode);\n            } else {\n                result.setEncoding('utf8');\n                result.on('data', sm.stepper());\n                result.on('end', this.reopen.bind(this, sm));\n            }\n        },\n\n        dataInitial: function (sm, chunk) {\n            var remaining = this.initialPayloadRemaining - chunk.length;\n            if (remaining > 0) {\n                this.initialPayloadRemaining = remaining;\n                sm.switchTo('dataInitial');\n            } else {\n                this.initialPayloadRemaining = this.initialPayloadLength;\n                if (remaining < 0) {\n                    (sm.stepper())(sm, chunk.slice(this.initialPayloadRemaining));\n                }\n            }\n        },\n\n        dataOpen: function (sm, chunk) {\n            var fsm;\n            chunk = this.partialChunk.concat(chunk);\n            if (chunk.length < 2) {\n                this.partialChunk = chunk;\n                sm.switchTo('dataOpen');\n            } else {\n                this.partialChunk = \"\";\n                if ('o\\n' === chunk.slice(0, 2)) {\n                    fsm = {};\n                    util.shallowCopy(this.fsm, fsm);\n                    this.fsm = fsm;\n                    fsm['dataInitial'] = 'running'; // from here on, another 'o\\n' is an error\n                    this.emit('connection', this);\n                    if (2 < chunk.length) {\n                        (sm.stepper())(sm, chunk.slice(2));\n                    }\n                } else {\n                    this.error(sm, chunk);\n                }\n            }\n        },\n\n        running: function (sm, chunk) {\n            var type;\n            chunk = this.partialChunk.concat(chunk);\n            if (1 < chunk.length) {\n                type = chunk.charAt(0);\n                switch (type) {\n                case 'h': // heartbeat\n                    this.partialChunk = chunk.slice(2);\n                    break;\n                case 'a': // data\n                    this.emitData(chunk, this.partialChunk.length);\n                    break;\n                case 'c': // close frame\n                    this.close();\n                    break;\n                default:\n                    this.error(sm, \"Unexpected frame type\", type, chunk);\n                }\n            } else {\n                this.partialChunk = chunk;\n            }\n        },\n\n        emitData: function (chunk, searchStart) {\n            var index = chunk.indexOf('\\n', searchStart),\n                array, i;\n            if (-1 === index) {\n                this.partialChunk = chunk;\n            } else {\n                index += 1;\n                if (index === chunk.length) {\n                    this.partialChunk = \"\";\n                } else {\n                    this.partialChunk = chunk.slice(index);\n                }\n                array = JSON.parse(chunk.slice(1, index));\n                for (i = 0; i < array.length; i += 1) {\n                    this.sjs.emit('data', array[i]);\n                }\n            }\n        },\n\n        reopen: function (sm) {\n            (sm.stepper('start'))();\n        },\n\n        error: function () {\n            if (undefined !== this.response) {\n                this.response.removeAllListeners();\n                this.response.destroy();\n            }\n            var args = Array.prototype.slice.call(arguments, 0),\n                sm;\n            sm = args.shift();\n            sm.switchTo('errored');\n            this.emit('error', args);\n        },\n\n        errored: function () {}\n    }\n\n    function StateMachine (callbacks) {\n        this.callbacks = callbacks;\n        this.stepper = Object.getPrototypeOf(this).stepper.bind(this);\n        this.fun = this.stepper();\n    }\n    StateMachine.prototype = {\n        invoke: function () {\n            if (undefined === this.fun) {\n                throw new InvalidState(this);\n            }\n            var args = Array.prototype.slice.call(arguments, 0);\n            args.unshift(this);\n            return this.fun.apply(this.callbacks, args);\n        },\n\n        nextStateName: function () {\n            if (util.hasOwnProperty(this, 'switchedTo')) {\n                return this.switchedTo;\n            } else if (util.hasOwnProperty(this, 'stateName')) {\n                return this.callbacks.fsm[this.stateName];\n            } else {\n                return 'start';\n            }\n        },\n\n        switchTo: function (name) {\n            if (undefined === name) {\n                delete this.switchedTo;\n            } else {\n                this.switchedTo = name;\n            }\n        },\n\n        stepper: function (name) {\n            return (function () {\n                if (undefined !== name) {\n                    this.switchTo(name);\n                }\n                this.stateName = this.nextStateName();\n                this.switchTo();\n                this.fun = this.callbacks[this.stateName];\n                this.invoke.apply(this, arguments);\n            }).bind(this);\n        }\n    };\n\n    exports.create = function (url) {\n        var sjsc = new SockJSClient(url);\n        sjsc.connect();\n        return sjsc;\n    };\n    exports.InvalidURL = InvalidURL;\n    exports.InvalidState = InvalidState;\n\n}(this));\n\n//@ sourceURL=/node_modules/sockjs-client/lib/sockjs-client.js"
));

require.define("url",Function(['require','module','exports','__dirname','__filename','process','global'],"var punycode = { encode : function (s) { return s } };\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nfunction arrayIndexOf(array, subject) {\n    for (var i = 0, j = array.length; i < j; i++) {\n        if(array[i] == subject) return i;\n    }\n    return -1;\n}\n\nvar objectKeys = Object.keys || function objectKeys(object) {\n    if (object !== Object(object)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;\n    return keys;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]+$/,\n    // RFC 2396: characters reserved for delimiting URLs.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '~', '[', ']', '`'].concat(delims),\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''],\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#']\n      .concat(unwise).concat(autoEscape),\n    nonAuthChars = ['/', '@', '?', '#'].concat(delims),\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,\n    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always have a path component.\n    pathedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof(url) === 'object' && url.href) return url;\n\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var out = {},\n      rest = url;\n\n  // cut off any delimiters.\n  // This is to support parse stuff like \"<http://foo.com>\"\n  for (var i = 0, l = rest.length; i < l; i++) {\n    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;\n  }\n  if (i !== 0) rest = rest.substr(i);\n\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    out.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      out.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    // don't enforce full RFC correctness, just be unstupid about it.\n\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the first @ sign, unless some non-auth character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    var atSign = arrayIndexOf(rest, '@');\n    if (atSign !== -1) {\n      // there *may be* an auth\n      var hasAuth = true;\n      for (var i = 0, l = nonAuthChars.length; i < l; i++) {\n        var index = arrayIndexOf(rest, nonAuthChars[i]);\n        if (index !== -1 && index < atSign) {\n          // not a valid auth.  Something like http://foo.com/bar@baz/\n          hasAuth = false;\n          break;\n        }\n      }\n      if (hasAuth) {\n        // pluck off the auth portion.\n        out.auth = rest.substr(0, atSign);\n        rest = rest.substr(atSign + 1);\n      }\n    }\n\n    var firstNonHost = -1;\n    for (var i = 0, l = nonHostChars.length; i < l; i++) {\n      var index = arrayIndexOf(rest, nonHostChars[i]);\n      if (index !== -1 &&\n          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;\n    }\n\n    if (firstNonHost !== -1) {\n      out.host = rest.substr(0, firstNonHost);\n      rest = rest.substr(firstNonHost);\n    } else {\n      out.host = rest;\n      rest = '';\n    }\n\n    // pull out port.\n    var p = parseHost(out.host);\n    var keys = objectKeys(p);\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      out[key] = p[key];\n    }\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    out.hostname = out.hostname || '';\n\n    // validate a little.\n    if (out.hostname.length > hostnameMaxLen) {\n      out.hostname = '';\n    } else {\n      var hostparts = out.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            out.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    // hostnames are always lower case.\n    out.hostname = out.hostname.toLowerCase();\n\n    // IDNA Support: Returns a puny coded representation of \"domain\".\n    // It only converts the part of the domain name that\n    // has non ASCII characters. I.e. it dosent matter if\n    // you call it with a domain that already is in ASCII.\n    var domainArray = out.hostname.split('.');\n    var newOut = [];\n    for (var i = 0; i < domainArray.length; ++i) {\n      var s = domainArray[i];\n      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n          'xn--' + punycode.encode(s) : s);\n    }\n    out.hostname = newOut.join('.');\n\n    out.host = (out.hostname || '') +\n        ((out.port) ? ':' + out.port : '');\n    out.href += out.host;\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n\n    // Now make sure that delims never appear in a url.\n    var chop = rest.length;\n    for (var i = 0, l = delims.length; i < l; i++) {\n      var c = arrayIndexOf(rest, delims[i]);\n      if (c !== -1) {\n        chop = Math.min(c, chop);\n      }\n    }\n    rest = rest.substr(0, chop);\n  }\n\n\n  // chop off from the tail first.\n  var hash = arrayIndexOf(rest, '#');\n  if (hash !== -1) {\n    // got a fragment string.\n    out.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = arrayIndexOf(rest, '?');\n  if (qm !== -1) {\n    out.search = rest.substr(qm);\n    out.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      out.query = querystring.parse(out.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    out.search = '';\n    out.query = {};\n  }\n  if (rest) out.pathname = rest;\n  if (slashedProtocol[proto] &&\n      out.hostname && !out.pathname) {\n    out.pathname = '/';\n  }\n\n  //to support http.request\n  if (out.pathname || out.search) {\n    out.path = (out.pathname ? out.pathname : '') +\n               (out.search ? out.search : '');\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  out.href = urlFormat(out);\n  return out;\n}\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (typeof(obj) === 'string') obj = urlParse(obj);\n\n  var auth = obj.auth || '';\n  if (auth) {\n    auth = auth.split('@').join('%40');\n    for (var i = 0, l = nonAuthChars.length; i < l; i++) {\n      var nAC = nonAuthChars[i];\n      auth = auth.split(nAC).join(encodeURIComponent(nAC));\n    }\n    auth += '@';\n  }\n\n  var protocol = obj.protocol || '',\n      host = (obj.host !== undefined) ? auth + obj.host :\n          obj.hostname !== undefined ? (\n              auth + obj.hostname +\n              (obj.port ? ':' + obj.port : '')\n          ) :\n          false,\n      pathname = obj.pathname || '',\n      query = obj.query &&\n              ((typeof obj.query === 'object' &&\n                objectKeys(obj.query).length) ?\n                 querystring.stringify(obj.query) :\n                 '') || '',\n      search = obj.search || (query && ('?' + query)) || '',\n      hash = obj.hash || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (obj.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  return protocol + host + pathname + search + hash;\n}\n\nfunction urlResolve(source, relative) {\n  return urlFormat(urlResolveObject(source, relative));\n}\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n\n  source = urlParse(urlFormat(source), false, true);\n  relative = urlParse(urlFormat(relative), false, true);\n\n  // hash is always overridden, no matter what.\n  source.hash = relative.hash;\n\n  if (relative.href === '') {\n    source.href = urlFormat(source);\n    return source;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    relative.protocol = source.protocol;\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[relative.protocol] &&\n        relative.hostname && !relative.pathname) {\n      relative.path = relative.pathname = '/';\n    }\n    relative.href = urlFormat(relative);\n    return relative;\n  }\n\n  if (relative.protocol && relative.protocol !== source.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      relative.href = urlFormat(relative);\n      return relative;\n    }\n    source.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      relative.pathname = relPath.join('/');\n    }\n    source.pathname = relative.pathname;\n    source.search = relative.search;\n    source.query = relative.query;\n    source.host = relative.host || '';\n    source.auth = relative.auth;\n    source.hostname = relative.hostname || relative.host;\n    source.port = relative.port;\n    //to support http.request\n    if (source.pathname !== undefined || source.search !== undefined) {\n      source.path = (source.pathname ? source.pathname : '') +\n                    (source.search ? source.search : '');\n    }\n    source.slashes = source.slashes || relative.slashes;\n    source.href = urlFormat(source);\n    return source;\n  }\n\n  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host !== undefined ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (source.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = source.pathname && source.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = source.protocol &&\n          !slashedProtocol[source.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // source.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n\n    delete source.hostname;\n    delete source.port;\n    if (source.host) {\n      if (srcPath[0] === '') srcPath[0] = source.host;\n      else srcPath.unshift(source.host);\n    }\n    delete source.host;\n    if (relative.protocol) {\n      delete relative.hostname;\n      delete relative.port;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      delete relative.host;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    source.host = (relative.host || relative.host === '') ?\n                      relative.host : source.host;\n    source.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : source.hostname;\n    source.search = relative.search;\n    source.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    source.search = relative.search;\n    source.query = relative.query;\n  } else if ('search' in relative) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      source.hostname = source.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?\n                       source.host.split('@') : false;\n      if (authInHost) {\n        source.auth = authInHost.shift();\n        source.host = source.hostname = authInHost.shift();\n      }\n    }\n    source.search = relative.search;\n    source.query = relative.query;\n    //to support http.request\n    if (source.pathname !== undefined || source.search !== undefined) {\n      source.path = (source.pathname ? source.pathname : '') +\n                    (source.search ? source.search : '');\n    }\n    source.href = urlFormat(source);\n    return source;\n  }\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    delete source.pathname;\n    //to support http.request\n    if (!source.search) {\n      source.path = '/' + source.search;\n    } else {\n      delete source.path;\n    }\n    source.href = urlFormat(source);\n    return source;\n  }\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (source.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    source.hostname = source.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?\n                     source.host.split('@') : false;\n    if (authInHost) {\n      source.auth = authInHost.shift();\n      source.host = source.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (source.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  source.pathname = srcPath.join('/');\n  //to support request.http\n  if (source.pathname !== undefined || source.search !== undefined) {\n    source.path = (source.pathname ? source.pathname : '') +\n                  (source.search ? source.search : '');\n  }\n  source.auth = relative.auth || source.auth;\n  source.slashes = source.slashes || relative.slashes;\n  source.href = urlFormat(source);\n  return source;\n}\n\nfunction parseHost(host) {\n  var out = {};\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    out.port = port.substr(1);\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) out.hostname = host;\n  return out;\n}\n\n//@ sourceURL=url"
));

require.define("querystring",Function(['require','module','exports','__dirname','__filename','process','global'],"var isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    };\n\nvar objectKeys = Object.keys || function objectKeys(object) {\n    if (object !== Object(object)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;\n    return keys;\n}\n\n\n/*!\n * querystring\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Library version.\n */\n\nexports.version = '0.3.1';\n\n/**\n * Object#toString() ref for stringify().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Cache non-integer test regexp.\n */\n\nvar notint = /[^0-9]/;\n\n/**\n * Parse the given query `str`, returning an object.\n *\n * @param {String} str\n * @return {Object}\n * @api public\n */\n\nexports.parse = function(str){\n  if (null == str || '' == str) return {};\n\n  function promote(parent, key) {\n    if (parent[key].length == 0) return parent[key] = {};\n    var t = {};\n    for (var i in parent[key]) t[i] = parent[key][i];\n    parent[key] = t;\n    return t;\n  }\n\n  return String(str)\n    .split('&')\n    .reduce(function(ret, pair){\n      try{ \n        pair = decodeURIComponent(pair.replace(/\\+/g, ' '));\n      } catch(e) {\n        // ignore\n      }\n\n      var eql = pair.indexOf('=')\n        , brace = lastBraceInKey(pair)\n        , key = pair.substr(0, brace || eql)\n        , val = pair.substr(brace || eql, pair.length)\n        , val = val.substr(val.indexOf('=') + 1, val.length)\n        , parent = ret;\n\n      // ?foo\n      if ('' == key) key = pair, val = '';\n\n      // nested\n      if (~key.indexOf(']')) {\n        var parts = key.split('[')\n          , len = parts.length\n          , last = len - 1;\n\n        function parse(parts, parent, key) {\n          var part = parts.shift();\n\n          // end\n          if (!part) {\n            if (isArray(parent[key])) {\n              parent[key].push(val);\n            } else if ('object' == typeof parent[key]) {\n              parent[key] = val;\n            } else if ('undefined' == typeof parent[key]) {\n              parent[key] = val;\n            } else {\n              parent[key] = [parent[key], val];\n            }\n          // array\n          } else {\n            obj = parent[key] = parent[key] || [];\n            if (']' == part) {\n              if (isArray(obj)) {\n                if ('' != val) obj.push(val);\n              } else if ('object' == typeof obj) {\n                obj[objectKeys(obj).length] = val;\n              } else {\n                obj = parent[key] = [parent[key], val];\n              }\n            // prop\n            } else if (~part.indexOf(']')) {\n              part = part.substr(0, part.length - 1);\n              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);\n              parse(parts, obj, part);\n            // key\n            } else {\n              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);\n              parse(parts, obj, part);\n            }\n          }\n        }\n\n        parse(parts, parent, 'base');\n      // optimize\n      } else {\n        if (notint.test(key) && isArray(parent.base)) {\n          var t = {};\n          for(var k in parent.base) t[k] = parent.base[k];\n          parent.base = t;\n        }\n        set(parent.base, key, val);\n      }\n\n      return ret;\n    }, {base: {}}).base;\n};\n\n/**\n * Turn the given `obj` into a query string\n *\n * @param {Object} obj\n * @return {String}\n * @api public\n */\n\nvar stringify = exports.stringify = function(obj, prefix) {\n  if (isArray(obj)) {\n    return stringifyArray(obj, prefix);\n  } else if ('[object Object]' == toString.call(obj)) {\n    return stringifyObject(obj, prefix);\n  } else if ('string' == typeof obj) {\n    return stringifyString(obj, prefix);\n  } else {\n    return prefix;\n  }\n};\n\n/**\n * Stringify the given `str`.\n *\n * @param {String} str\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyString(str, prefix) {\n  if (!prefix) throw new TypeError('stringify expects an object');\n  return prefix + '=' + encodeURIComponent(str);\n}\n\n/**\n * Stringify the given `arr`.\n *\n * @param {Array} arr\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[]'));\n  }\n  return ret.join('&');\n}\n\n/**\n * Stringify the given `obj`.\n *\n * @param {Object} obj\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyObject(obj, prefix) {\n  var ret = []\n    , keys = objectKeys(obj)\n    , key;\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    ret.push(stringify(obj[key], prefix\n      ? prefix + '[' + encodeURIComponent(key) + ']'\n      : encodeURIComponent(key)));\n  }\n  return ret.join('&');\n}\n\n/**\n * Set `obj`'s `key` to `val` respecting\n * the weird and wonderful syntax of a qs,\n * where \"foo=bar&foo=baz\" becomes an array.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {String} val\n * @api private\n */\n\nfunction set(obj, key, val) {\n  var v = obj[key];\n  if (undefined === v) {\n    obj[key] = val;\n  } else if (isArray(v)) {\n    v.push(val);\n  } else {\n    obj[key] = [v, val];\n  }\n}\n\n/**\n * Locate last brace in `str` within the key.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction lastBraceInKey(str) {\n  var len = str.length\n    , brace\n    , c;\n  for (var i = 0; i < len; ++i) {\n    c = str[i];\n    if (']' == c) brace = false;\n    if ('[' == c) brace = true;\n    if ('=' == c && !brace) return i;\n  }\n}\n\n//@ sourceURL=querystring"
));

require.define("http",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"http-browserify\")\n//@ sourceURL=http"
));

require.define("/node_modules/http-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"index.js\"}\n//@ sourceURL=/node_modules/http-browserify/package.json"
));

require.define("/node_modules/http-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var http = module.exports;\nvar EventEmitter = require('events').EventEmitter;\nvar Request = require('./lib/request');\n\nhttp.request = function (params, cb) {\n    if (!params) params = {};\n    if (!params.host) params.host = window.location.host.split(':')[0];\n    if (!params.port) params.port = window.location.port;\n    \n    var req = new Request(new xhrHttp, params);\n    if (cb) req.on('response', cb);\n    return req;\n};\n\nhttp.get = function (params, cb) {\n    params.method = 'GET';\n    var req = http.request(params, cb);\n    req.end();\n    return req;\n};\n\nhttp.Agent = function () {};\nhttp.Agent.defaultMaxSockets = 4;\n\nvar xhrHttp = (function () {\n    if (typeof window === 'undefined') {\n        throw new Error('no window object present');\n    }\n    else if (window.XMLHttpRequest) {\n        return window.XMLHttpRequest;\n    }\n    else if (window.ActiveXObject) {\n        var axs = [\n            'Msxml2.XMLHTTP.6.0',\n            'Msxml2.XMLHTTP.3.0',\n            'Microsoft.XMLHTTP'\n        ];\n        for (var i = 0; i < axs.length; i++) {\n            try {\n                var ax = new(window.ActiveXObject)(axs[i]);\n                return function () {\n                    if (ax) {\n                        var ax_ = ax;\n                        ax = null;\n                        return ax_;\n                    }\n                    else {\n                        return new(window.ActiveXObject)(axs[i]);\n                    }\n                };\n            }\n            catch (e) {}\n        }\n        throw new Error('ajax not supported in this browser')\n    }\n    else {\n        throw new Error('ajax not supported in this browser');\n    }\n})();\n\n//@ sourceURL=/node_modules/http-browserify/index.js"
));

require.define("/node_modules/http-browserify/lib/request.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar Response = require('./response');\nvar concatStream = require('concat-stream')\n\nvar Request = module.exports = function (xhr, params) {\n    var self = this;\n    self.writable = true;\n    self.xhr = xhr;\n    self.body = concatStream()\n    \n    var uri = params.host + ':' + params.port + (params.path || '/');\n    \n    xhr.open(\n        params.method || 'GET',\n        (params.scheme || 'http') + '://' + uri,\n        true\n    );\n    \n    if (params.headers) {\n        Object.keys(params.headers).forEach(function (key) {\n            if (!self.isSafeRequestHeader(key)) return;\n            var value = params.headers[key];\n            if (Array.isArray(value)) {\n                value.forEach(function (v) {\n                    xhr.setRequestHeader(key, v);\n                });\n            }\n            else xhr.setRequestHeader(key, value)\n        });\n    }\n    \n    var res = new Response;\n    res.on('ready', function () {\n        self.emit('response', res);\n    });\n    \n    xhr.onreadystatechange = function () {\n        res.handle(xhr);\n    };\n};\n\nRequest.prototype = new Stream;\n\nRequest.prototype.setHeader = function (key, value) {\n    if ((Array.isArray && Array.isArray(value))\n    || value instanceof Array) {\n        for (var i = 0; i < value.length; i++) {\n            this.xhr.setRequestHeader(key, value[i]);\n        }\n    }\n    else {\n        this.xhr.setRequestHeader(key, value);\n    }\n};\n\nRequest.prototype.write = function (s) {\n    this.body.write(s);\n};\n\nRequest.prototype.end = function (s) {\n    if (s !== undefined) this.body.write(s);\n    this.body.end()\n    this.xhr.send(this.body.getBody());\n};\n\n// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html\nRequest.unsafeHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"cookie\",\n    \"cookie2\",\n    \"content-transfer-encoding\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"user-agent\",\n    \"via\"\n];\n\nRequest.prototype.isSafeRequestHeader = function (headerName) {\n    if (!headerName) return false;\n    return (Request.unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)\n};\n\n//@ sourceURL=/node_modules/http-browserify/lib/request.js"
));

require.define("/node_modules/http-browserify/lib/response.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\n\nvar Response = module.exports = function (res) {\n    this.offset = 0;\n    this.readable = true;\n};\n\nResponse.prototype = new Stream;\n\nvar capable = {\n    streaming : true,\n    status2 : true\n};\n\nfunction parseHeaders (res) {\n    var lines = res.getAllResponseHeaders().split(/\\r?\\n/);\n    var headers = {};\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        if (line === '') continue;\n        \n        var m = line.match(/^([^:]+):\\s*(.*)/);\n        if (m) {\n            var key = m[1].toLowerCase(), value = m[2];\n            \n            if (headers[key] !== undefined) {\n                if ((Array.isArray && Array.isArray(headers[key]))\n                || headers[key] instanceof Array) {\n                    headers[key].push(value);\n                }\n                else {\n                    headers[key] = [ headers[key], value ];\n                }\n            }\n            else {\n                headers[key] = value;\n            }\n        }\n        else {\n            headers[line] = true;\n        }\n    }\n    return headers;\n}\n\nResponse.prototype.getResponse = function (xhr) {\n    var respType = xhr.responseType.toLowerCase();\n    if (respType === \"blob\") return xhr.responseBlob;\n    if (respType === \"arraybuffer\") return xhr.response;\n    return xhr.responseText;\n}\n\nResponse.prototype.getHeader = function (key) {\n    return this.headers[key.toLowerCase()];\n};\n\nResponse.prototype.handle = function (res) {\n    if (res.readyState === 2 && capable.status2) {\n        try {\n            this.statusCode = res.status;\n            this.headers = parseHeaders(res);\n        }\n        catch (err) {\n            capable.status2 = false;\n        }\n        \n        if (capable.status2) {\n            this.emit('ready');\n        }\n    }\n    else if (capable.streaming && res.readyState === 3) {\n        try {\n            if (!this.statusCode) {\n                this.statusCode = res.status;\n                this.headers = parseHeaders(res);\n                this.emit('ready');\n            }\n        }\n        catch (err) {}\n        \n        try {\n            this.write(res);\n        }\n        catch (err) {\n            capable.streaming = false;\n        }\n    }\n    else if (res.readyState === 4) {\n        if (!this.statusCode) {\n            this.statusCode = res.status;\n            this.emit('ready');\n        }\n        this.write(res);\n        \n        if (res.error) {\n            this.emit('error', this.getResponse(res));\n        }\n        else this.emit('end');\n    }\n};\n\nResponse.prototype.write = function (res) {\n    var respBody = this.getResponse(res);\n    if (respBody.toString().match(/ArrayBuffer/)) {\n        this.emit('data', new Uint8Array(respBody, this.offset));\n        this.offset = respBody.byteLength;\n        return;\n    }\n    if (respBody.length > this.offset) {\n        this.emit('data', respBody.slice(this.offset));\n        this.offset = respBody.length;\n    }\n};\n\n//@ sourceURL=/node_modules/http-browserify/lib/response.js"
));

require.define("/node_modules/http-browserify/node_modules/concat-stream/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/http-browserify/node_modules/concat-stream/package.json"
));

require.define("/node_modules/http-browserify/node_modules/concat-stream/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var stream = require('stream')\nvar util = require('util')\n\nfunction ConcatStream(cb) {\n  stream.Stream.call(this)\n  this.writable = true\n  if (cb) this.cb = cb\n  this.body = []\n  if (this.cb) this.on('error', cb)\n}\n\nutil.inherits(ConcatStream, stream.Stream)\n\nConcatStream.prototype.write = function(chunk) {\n  this.body.push(chunk)\n}\n\nConcatStream.prototype.arrayConcat = function(arrs) {\n  if (arrs.length === 0) return []\n  if (arrs.length === 1) return arrs[0]\n  return arrs.reduce(function (a, b) { return a.concat(b) })\n}\n\nConcatStream.prototype.isArray = function(arr) {\n  var isArray = Array.isArray(arr)\n  var isTypedArray = arr.toString().match(/Array/)\n  return isArray || isTypedArray\n}\n\nConcatStream.prototype.getBody = function () {\n  if (this.body.length === 0) return\n  if (typeof(this.body[0]) === \"string\") return this.body.join('')\n  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)\n  if (typeof(Buffer) !== \"undefined\" && Buffer.isBuffer(this.body[0])) {\n    return Buffer.concat(this.body)\n  }\n  return this.body\n}\n\nConcatStream.prototype.end = function() {\n  if (this.cb) this.cb(false, this.getBody())\n}\n\nmodule.exports = function(cb) {\n  return new ConcatStream(cb)\n}\n\nmodule.exports.ConcatStream = ConcatStream\n\n//@ sourceURL=/node_modules/http-browserify/node_modules/concat-stream/index.js"
));

require.define("https",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require('http');\n\n//@ sourceURL=https"
));

require.define("/node_modules/sockjs-client/node_modules/node-uuid/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/sockjs-client/node_modules/node-uuid/package.json"
));

require.define("/node_modules/sockjs-client/node_modules/node-uuid/uuid.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[byte];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/sockjs-client/node_modules/node-uuid/uuid.js"
));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"
));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"
));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"
));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"
));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"
));

require.define("/example/invert/node_modules/event-stream/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/example/invert/node_modules/event-stream/package.json"
));

require.define("/example/invert/node_modules/event-stream/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n  , es = exports\n\nes.Stream = Stream //re-export Stream from core\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nes.through = function (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = (\n    'sync'== end || !end\n  //use sync end. (default)\n  ? function () { this.emit('end') }\n  : 'async' == end || end === true \n  //use async end.\n  //must eventually call drain if paused.\n  //else will not end.\n  ? function () {\n      if(!this.paused)\n        return this.emit('end')\n     var self = this\n     this.once('drain', function () {\n        self.emit('end')\n      })\n    }\n  //use custom end function\n  : end \n  )\n  var ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      stream.destroy()\n  })\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  /*\n    destroy is called on a writable stream when the upstream closes.\n    it's basically END but something has gone wrong.\n    I'm gonna emit 'close' and change then otherwise act as 'end'\n  */\n  stream.destroy = function () {\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    stream.paused = true\n  }\n  stream.resume = function () {\n    if(stream.paused)\n      stream.emit('drain')\n    stream.paused = false\n  }\n  return stream\n}\n\n// buffered\n//\n// same as a through stream, but won't emit a chunk until the next tick.\n// does not support any pausing. intended for testing purposes.\n\n// XXX: rewrite this. this is crap. but do I actually use it? maybe just throw it away?\n// okay, it's used in snob. so... throw this out and let snob use a legacy version. (fix later/never)\n\n\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  var stream = new Stream()\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  toMerge.forEach(function (e) {\n    e.pipe(stream, {end: false})\n    var ended = false\n    e.on('end', function () {\n      if(ended) return\n      ended = true\n      endCount ++\n      if(endCount == toMerge.length)\n        stream.emit('end') \n    })\n  })\n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n\n  return stream\n}\n\n\n// writable stream, collects all events into an array \n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = []\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n \n  stream.readable = true  \n  stream.writable = false\n \n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n  \n  stream.resume = function () {\n    paused = false\n    var l = array.length\n    while(i < l && !paused) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l)\n      stream.emit('end'), stream.readable = false\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\nes.readable = function (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true  \n  stream.writable = false\n \n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n  \n  stream.on('end', function () { ended = true })\n  \n  function get (err, data) {\n    \n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    process.nextTick(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)    \n      }\n    })\n  \n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('close')\n    stream.emit('end')\n    ended = true\n  }\n  return stream\n}\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nes.map = function (mapper) {\n  var stream = new Stream()\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n\n  stream.writable = true\n  stream.readable = true\n   \n  stream.write = function () {\n    if(ended) throw new Error('map stream is not writable')\n    inputs ++\n    var args = [].slice.call(arguments)\n      , r\n      , inNext = false \n    //pipe only allows one argument. so, do not \n    function next (err) {\n      if(destroyed) return\n      inNext = true\n      outputs ++\n      var args = [].slice.call(arguments)\n      if(err) {\n        args.unshift('error')\n        return inNext = false, stream.emit.apply(stream, args)\n      }\n      args.shift() //drop err\n      if (args.length){\n        args.unshift('data')\n        r = stream.emit.apply(stream, args)\n      }\n      if(inputs == outputs) {\n        if(paused) paused = false, stream.emit('drain') //written all the incoming events\n        if(ended)\n          stream.end()\n      }\n      inNext = false\n    }\n    args.push(next)\n    \n    try {\n      //catch sync errors and handle them like async errors\n      var written = mapper.apply(null, args)\n      if(written === false) paused = true\n      return written\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return true\n    }\n  }\n\n  stream.end = function () {\n    var args = [].slice.call(arguments)\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    if(args.length)\n      return stream.write.apply(emitter, args)\n    else if (inputs == outputs) //wait for processing\n      stream.emit('end')\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n  }\n\n  return stream\n}\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) { \n  return es.through(function write(data) {\n    var mappedData = sync(data)\n    if (typeof mappedData !== 'undefined')\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n//\n// combine multiple streams together so that they act as a single stream\n//\n\nes.pipe = es.connect = function () {\n\n  var streams = [].slice.call(arguments)\n    , first = streams[0]\n    , last = streams[streams.length - 1]\n    , thepipe = es.duplex(first, last)\n\n  if(streams.length == 1)\n    return streams[0]\n  else if (!streams.length)\n    throw new Error('connect called with empty args')\n\n  //pipe all the streams together\n\n  function recurse (streams) {\n    if(streams.length < 2)\n      return\n    streams[0].pipe(streams[1])\n    recurse(streams.slice(1))  \n  }\n  \n  recurse(streams)\n \n  function onerror () {\n    var args = [].slice.call(arguments)\n    args.unshift('error')\n    thepipe.emit.apply(thepipe, args)\n  }\n  \n  streams.forEach(function (stream) {\n    stream.on('error', onerror)\n  })\n\n  return thepipe\n}\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\n//\n// duplex -- pipe into one stream and out another\n//\n\nes.duplex = function (writer, reader) {\n  var thepipe = new Stream()\n\n  thepipe.__defineGetter__('writable', function () { return writer.writable })\n  thepipe.__defineGetter__('readable', function () { return reader.readable })\n\n  ;['write', 'end', 'close'].forEach(function (func) {\n    thepipe[func] = function () {\n      return writer[func].apply(writer, arguments)\n    }\n  })\n\n  ;['resume', 'pause'].forEach(function (func) {\n    thepipe[func] = function () { \n      thepipe.emit(func)\n      if(reader[func])\n        return reader[func].apply(reader, arguments)\n      else\n        reader.emit(func)\n    }\n  })\n\n  ;['data', 'close'].forEach(function (event) {\n    reader.on(event, function () {\n      var args = [].slice.call(arguments)\n      args.unshift(event)\n      thepipe.emit.apply(thepipe, args)\n    })\n  })\n  //only emit end once\n  var ended = false\n  reader.on('end', function () {\n    if(ended) return\n    ended = true\n    var args = [].slice.call(arguments)\n    args.unshift('end')\n    thepipe.emit.apply(thepipe, args)\n  })\n\n  thepipe.destroy = function () {\n    if(reader.destroy)\n      reader.destroy()\n    if(writer.destroy)\n      writer.destroy()\n  }\n\n  return thepipe\n}\n\nes.split = function (matcher) {\n  var soFar = ''\n  if (!matcher)\n    matcher = '\\n'\n\n  return es.through(function (buffer) { \n    var stream = this\n      , pieces = (soFar + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    pieces.forEach(function (piece) {\n      stream.emit('data', piece)\n    })\n\n    return true\n  },\n  function () {\n    if(soFar)\n      this.emit('data', soFar)  \n    this.emit('end')\n  })\n}\n\n//\n// gate \n//\n// while the gate is shut(), buffer incoming. \n// \n// if gate is open() stream like normal.\n//\n// currently, when opened, this will emit all data unless it is shut again\n// if downstream pauses it will still write, i'd like to make it respect pause, \n// but i'll need a test case first.\n\nes.gate = function (shut) {\n\n  var stream = new Stream()\n    , queue = []\n    , ended = false\n\n    shut = (shut === false ? false : true) //default to shut\n\n  stream.writable = true\n  stream.readable = true\n\n  stream.isShut = function () { return shut }\n  stream.shut   = function () { shut = true }\n  stream.open   = function () { shut = false; maybe() }\n  \n  function maybe () {\n    while(queue.length && !shut) {\n      var args = queue.shift()\n      args.unshift('data')\n      stream.emit.apply(stream, args)\n    }\n    stream.emit('drain')\n    if(ended && !shut) \n      stream.emit('end')\n  }\n  \n  stream.write = function () {\n    var args = [].slice.call(arguments)\n  \n    queue.push(args)\n    if (shut) return false //pause up stream pipes  \n\n    maybe()\n  }\n\n  stream.end = function () {\n    ended = true\n    if (!queue.length)\n      stream.emit('end')\n  }\n\n  return stream\n}\n\n//\n// parse\n//\n\nes.parse = function () { \n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      return console.error(err, 'attemping to parse:', data)\n    }\n    this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () { \n  return es.mapSync(function (e){\n    return JSON.stringify(e) + '\\n'\n  }) \n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join(). \n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.connect(es.split(from), es.join(to))\n} \n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n// \n\nes.join = function (str) {\n  \n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var stream = new Stream()\n  var first = true\n  stream.readable = stream.writable = true\n  stream.write = function (data) {\n    if(!first)\n      stream.emit('data', str)\n    first = false\n    stream.emit('data', data)\n    return true\n  }\n  stream.end = function (data) {\n    if(data)\n      this.write(data)\n    this.emit('end')\n  }\n  return stream\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var stream = new Stream()\n  var body = ''\n  stream.readable = true\n  stream.writable = true\n  stream.write = function (data) { body += data }\n  stream.end = function (data) {\n    if(data)\n      body += data\n    if(callback)\n      callback(null, body)\n    stream.emit('data', body)\n    stream.emit('end')\n  }\n  return stream\n}\n\n//\n// helper to make your module into a unix pipe\n// simply add \n// \n// if(!module.parent)\n//  require('event-stream').pipable(asyncFunctionOrStreams)\n// \n// asyncFunctionOrStreams may be one or more Streams or if it is a function, \n// it will be automatically wrapped in es.map\n//\n// then pipe stuff into from the command line!\n// \n// curl registry.npmjs.org/event-stream | node hello-pipeable.js | grep whatever\n//\n// etc!\n//\n// also, start pipeable running as a server!\n//\n// > node hello-pipeable.js --port 44444\n// \n\nvar setup = function (args) {\n  return args.map(function (f) {\n    var x = f()\n      if('function' === typeof x)\n        return es.map(x)\n      return x\n    })\n}\n\nes.pipeable = function () {\n  if(process.title != 'node')\n    return console.error('cannot use es.pipeable in the browser')\n  //(require) inside brackets to fool browserify, because this does not make sense in the browser.\n  var opts = (require)('optimist').argv\n  var args = [].slice.call(arguments)\n  \n  if(opts.h || opts.help) {\n    var name = process.argv[1]\n    console.error([\n      'Usage:',\n      '',\n      'node ' + name + ' [options]',\n      '  --port PORT        turn this stream into a server',\n      '  --host HOST        host of server (localhost is default)',\n      '  --protocol         protocol http|net will require(protocol).createServer(...',\n      '  --help             display this message',\n      '',\n      ' if --port is not set, will stream input from stdin',\n      '',\n      'also, pipe from or to files:',\n      '',\n      ' node '+name+ ' < file    #pipe from file into this stream',\n      ' node '+name+ ' < infile > outfile    #pipe from file into this stream',     \n      '',\n    ].join('\\n'))\n  \n  } else if (!opts.port) {\n    var streams = setup(args)\n    streams.unshift(es.split())\n    //streams.unshift()\n    streams.push(process.stdout)\n    var c = es.connect.apply(null, streams)\n    process.openStdin().pipe(c) //there\n    return c\n\n  } else {\n  \n    opts.host = opts.host || 'localhost'\n    opts.protocol = opts.protocol || 'http'\n    \n    var protocol = (require)(opts.protocol)\n        \n    var server = protocol.createServer(function (instream, outstream) {  \n      var streams = setup(args)\n      streams.unshift(es.split())\n      streams.unshift(instream)\n      streams.push(outstream || instream)\n      es.pipe.apply(null, streams)\n    })\n    \n    server.listen(opts.port, opts.host)\n\n    console.error(process.argv[1] +' is listening for \"' + opts.protocol + '\" on ' + opts.host + ':' + opts.port)  \n  }\n}\n\n//@ sourceURL=/example/invert/node_modules/event-stream/index.js"
));

require.define("/example/invert/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var shoe = require('../../');\nvar es = require('event-stream');\n\nvar result = document.getElementById('result');\n\nvar stream = shoe('/invert');\nvar s = es.mapSync(function (msg) {\n    result.appendChild(document.createTextNode(msg));\n    return String(Number(msg)^1);\n});\ns.pipe(stream).pipe(s);\n\n//@ sourceURL=/example/invert/client.js"
));
require("/example/invert/client.js");
})();
